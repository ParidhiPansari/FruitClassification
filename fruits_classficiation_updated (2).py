# -*- coding: utf-8 -*-
"""fruits_classficiation_updated.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HxaLza635awUrGF8zWX4rMQrm1Y8gIi8
"""

! pip install -q kaggle
from google.colab import files
files.upload()
!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download sshikamaru/fruit-recognition
! unzip /content/fruit-recognition.zip -d data

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
import os
import matplotlib.image as mpimg
import random
from tensorflow.keras.utils import load_img, img_to_array
import pathlib
from tensorflow.keras import layers
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split

train_data_path = "/content/data/train/train/"
test_data_path = "/content/data/test/test/"

# Creating a pathlib.Path object for the training data directory
train_data_dir = pathlib.Path(train_data_path)

data_class = np.array(sorted([classes.name for classes in train_data_dir.glob('*')]))
print(data_class)

train_data_dict = {'file_path' : [], 'file_name': [], 'class': []}

for dir_path, dirnames, filenames in os.walk(train_data_path):
    # For each file in the current directory
    for f in filenames:
        train_data_dict['file_path'].append(dir_path)
        train_data_dict['file_name'].append(f)
        train_data_dict['class'].append(f.split('_')[0])

# Create a dictionary to store test data
test_data_dict = {'file_path' : [], 'file_name': []}

# Traverse through each directory and file in the test data directory
for dirpath, dirnames, filenames in os.walk(test_data_path):
    # For each file in the current directory
    for f in filenames:
        # Append the path to the file to the dictionary
        test_data_dict['file_path'].append(dirpath)
        test_data_dict['file_name'].append(f)

# Create a pandas DataFrame from the train data dictionary
train_dataframe = pd.DataFrame(train_data_dict)

test_dataframe = pd.DataFrame(test_data_dict)

print('Training data images', train_dataframe.shape[0])
print('Testing data images', test_dataframe.shape[0])

train_dataframe.head(15)

test_dataframe.head(15)

print('Class count in Training data')
train_dataframe.groupby('class')['class'].count().sort_values(ascending = False)

# Create empty lists to store images and their corresponding labels
image_array = []
labels_array = []

for index, single_image in train_dataframe.iterrows():

    current_img = img_to_array(load_img(os.path.join(single_image['file_path'], single_image['file_name'])))

    image_array.append(current_img)
    labels_array.append(single_image['class'])
test_images = []

for _, row in test_dataframe.iterrows():
    img = load_img(os.path.join(row['file_path'], row['file_name']))
    img_array = img_to_array(img)
    test_images.append(img_array)

image_array = np.array(image_array)
labels_array = np.array(labels_array)
test_images = np.array(test_images)

print('Single Image Shape:- ', image_array[0].shape)

plt.figure(figsize = (15,10))

for i in range(len(data_class)):

    plt.subplot(5, 8, i+1)
    if train_data_path  not in data_class[i]:
      class_dir = train_data_path + data_class[i]
    else:
      class_dir = data_class[i]


    random_image_path = random.sample(os.listdir(class_dir), 1)[0]

    current_img = mpimg.imread(class_dir + "/" + random_image_path)

    plt.imshow(current_img)
    plt.title(data_class[i])
    plt.axis("off")

# Show the plot
plt.show()

# Create an empty dictionary to store the fruit class indices
fruit_class_indices = {}

for i in range(len(data_class)):
    fruit_class_indices[data_class[i]] = i

label_indices = []
for fruit_label in labels_array:
    label_indices.append(fruit_class_indices[fruit_label])

label_categorical = tf.keras.utils.to_categorical(label_indices, num_classes=len(data_class), dtype='uint8')

model = tf.keras.Sequential()

model.add(tf.keras.applications.mobilenet.MobileNet(weights='imagenet',
                                                    include_top=False,
                                                    input_shape=(100, 100, 3)))
model.add(tf.keras.layers.Flatten())
model.add(tf.keras.layers.Dense(256, activation='relu'))
model.add(tf.keras.layers.Dropout(0.5))
model.add(tf.keras.layers.Dense(33, activation='softmax'))

model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])
model.summary()

early_stop = tf.keras.callbacks.EarlyStopping(monitor='loss', patience=5, verbose=1, mode='min', restore_best_weights=True)

history = model.fit(x = image_array, y = label_categorical, epochs=10, steps_per_epoch = len(image_array)/ 32, batch_size = 32, )

print(history.history)

random_index = np.random.choice(range(len(image_array)), size = 1000)
train_random_image = image_array[random_index]
print('Random sample images', len(train_random_image))
train_random_label = np.array(label_indices)[random_index]

train_predicted_output = model.predict(train_random_image)
final_predicted_class = []
for single_output in train_predicted_output:
  final_predicted_class.append(np.argmax(single_output))

reverse_encoding = {v: k for k, v in fruit_class_indices.items()}

predicted_class = [reverse_encoding[v] for v in final_predicted_class]
original_class = [reverse_encoding[v] for v in train_random_label]

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix


accuracy = accuracy_score(original_class, predicted_class)
precision = precision_score(original_class, predicted_class, average='macro')
recall = recall_score(original_class, original_class, average='macro')
f1 = f1_score(original_class, predicted_class, average='macro')

print("Accuracy", accuracy)
print("Precision", precision)
print("Recall", recall)
print("F1 score", f1)

cf_matrix = confusion_matrix(original_class, predicted_class, labels = list(fruit_class_indices.keys()))

plt.figure(figsize=(8, 8))
plt.imshow(cf_matrix)
plt.title("Training data Confusion Matrix")
plt.colorbar()

tick_marks = np.arange(len(data_class))
plt.xticks(tick_marks, data_class, rotation=90)
plt.yticks(tick_marks, data_class)
plt.show()

plt.plot(history.history['accuracy'])
plt.title('Model Training Accuracy Graph')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.xticks(range(10))
plt.show()

plt.plot(history.history['loss'])
plt.title('Training Loss Graph')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.xticks(range(10))
plt.show()

